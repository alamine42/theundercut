<script>
// Tire compound colors (classic)
const COMPOUND_COLORS = {
  'SOFT': '#C41E3A',
  'MEDIUM': '#F5D547',
  'HARD': '#EEEEEE',
  'INTERMEDIATE': '#4CAF50',
  'WET': '#2196F3',
  'UNKNOWN': '#9E9E9E'
};

const COMPOUND_BORDER_COLORS = {
  'SOFT': '#8B1528',
  'MEDIUM': '#C4A83A',
  'HARD': '#CCCCCC',
  'INTERMEDIATE': '#388E3C',
  'WET': '#1976D2',
  'UNKNOWN': '#666666'
};

// Vintage team-inspired driver colors
const DRIVER_COLORS = {
  'VER': '#1E3A8A', 'PER': '#3B82F6',  // Red Bull blues
  'HAM': '#059669', 'RUS': '#10B981',  // Mercedes greens
  'LEC': '#DC2626', 'SAI': '#EF4444',  // Ferrari reds
  'NOR': '#E8752A', 'PIA': '#F59E0B',  // McLaren orange
  'ALO': '#166534', 'STR': '#22C55E',  // Aston Martin
  'GAS': '#5B9BD5', 'OCO': '#3B82F6',  // Alpine blue
  'BOT': '#991B1B', 'ZHO': '#B91C1C',  // Sauber/Alfa red
  'TSU': '#1E40AF', 'RIC': '#6366F1', 'LAW': '#8B5CF6',  // RB/AlphaTauri
  'MAG': '#6B7280', 'HUL': '#9CA3AF',  // Haas grays
  'ALB': '#0EA5E9', 'SAR': '#38BDF8', 'COL': '#7DD3FC',  // Williams blues
};

function getDriverColor(driver, alpha = 1) {
  const baseColor = DRIVER_COLORS[driver] || '#7A7A7A';
  const r = parseInt(baseColor.slice(1, 3), 16);
  const g = parseInt(baseColor.slice(3, 5), 16);
  const b = parseInt(baseColor.slice(5, 7), 16);
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

// Chart.js defaults for gallery dark theme
if (typeof Chart !== 'undefined') {
  Chart.defaults.font.family = "'Rubik', -apple-system, sans-serif";
  Chart.defaults.color = 'rgba(255, 255, 255, 0.6)';
  Chart.defaults.plugins.legend.labels.color = 'rgba(255, 255, 255, 0.85)';
  Chart.defaults.plugins.tooltip.backgroundColor = '#022A33';
  Chart.defaults.plugins.tooltip.titleColor = '#FECD8C';
  Chart.defaults.plugins.tooltip.bodyColor = '#FFFFFF';
  Chart.defaults.plugins.tooltip.borderColor = 'rgba(255, 255, 255, 0.15)';
  Chart.defaults.plugins.tooltip.borderWidth = 1;
  Chart.defaults.plugins.tooltip.cornerRadius = 6;
}

function destroyChart(id) {
  if (window.chartInstances[id]) {
    window.chartInstances[id].destroy();
    delete window.chartInstances[id];
  }
}

function showChart(id) {
  const canvas = document.getElementById(id);
  if (canvas) {
    canvas.style.display = 'block';
    const loader = canvas.parentElement.querySelector('.chart-loading');
    if (loader) loader.style.display = 'none';
  }
}

function renderLapTimeChart(data) {
  destroyChart('lapTimeChart');
  const ctx = document.getElementById('lapTimeChart');
  if (!ctx) return;

  const laps = data.laps.filter(l => l.lap_ms && l.lap_ms > 0);
  if (laps.length === 0) {
    const loader = ctx.parentElement.querySelector('.chart-loading');
    if (loader) {
      loader.style.display = 'flex';
      loader.textContent = 'No lap data available';
    }
    return;
  }

  const drivers = [...new Set(laps.map(l => l.driver))].sort();
  const datasets = drivers.map(driver => {
    const driverLaps = laps
      .filter(l => l.driver === driver)
      .sort((a, b) => a.lap - b.lap);

    return {
      label: driver,
      data: driverLaps.map(l => ({
        x: l.lap,
        y: l.lap_ms / 1000,
        compound: l.compound,
        pit: l.pit
      })),
      borderColor: getDriverColor(driver),
      backgroundColor: getDriverColor(driver, 0.1),
      borderWidth: 2,
      pointRadius: (ctx) => {
        const point = ctx.raw;
        return point && point.pit ? 6 : 2;
      },
      pointStyle: (ctx) => {
        const point = ctx.raw;
        return point && point.pit ? 'triangle' : 'circle';
      },
      pointBackgroundColor: (ctx) => {
        const point = ctx.raw;
        return COMPOUND_COLORS[point.compound] || getDriverColor(driver);
      },
      tension: 0.2,
      fill: false
    };
  });

  window.chartInstances['lapTimeChart'] = new Chart(ctx, {
    type: 'line',
    data: { datasets },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      interaction: { mode: 'nearest', intersect: false },
      plugins: {
        legend: {
          position: 'bottom',
          labels: { boxWidth: 12, usePointStyle: true, padding: 15 }
        },
        tooltip: {
          callbacks: {
            label: (item) => {
              const point = item.raw;
              let label = `${item.dataset.label}: ${point.y.toFixed(3)}s`;
              if (point.compound) label += ` (${point.compound})`;
              if (point.pit) label += ' [PIT]';
              return label;
            }
          }
        }
      },
      scales: {
        x: {
          type: 'linear',
          title: { display: true, text: 'Lap', color: 'rgba(255, 255, 255, 0.5)' },
          min: 1,
          grid: { color: 'rgba(255, 255, 255, 0.08)' },
          ticks: { color: 'rgba(255, 255, 255, 0.6)' }
        },
        y: {
          title: { display: true, text: 'Lap Time (seconds)', color: 'rgba(255, 255, 255, 0.5)' },
          suggestedMin: Math.min(...laps.map(l => l.lap_ms)) / 1000 - 2,
          suggestedMax: Math.max(...laps.map(l => l.lap_ms)) / 1000 + 2,
          grid: { color: 'rgba(255, 255, 255, 0.08)' },
          ticks: { color: 'rgba(255, 255, 255, 0.6)' }
        }
      }
    }
  });

  showChart('lapTimeChart');
}

function renderPaceComparisonChart(data) {
  destroyChart('paceComparisonChart');
  const ctx = document.getElementById('paceComparisonChart');
  if (!ctx) return;

  const grades = data.driver_pace_grades || [];
  if (grades.length === 0) {
    const loader = ctx.parentElement.querySelector('.chart-loading');
    if (loader) {
      loader.style.display = 'flex';
      loader.textContent = 'No pace data available';
    }
    return;
  }

  const sorted = [...grades].sort((a, b) => (a.pace_delta_ms || 0) - (b.pace_delta_ms || 0));

  window.chartInstances['paceComparisonChart'] = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: sorted.map(g => g.driver),
      datasets: [{
        label: 'Pace Delta (seconds)',
        data: sorted.map(g => ((g.pace_delta_ms || 0) / 1000)),
        backgroundColor: sorted.map((g, i) => {
          // Gradient from gold to sage for dark theme
          const ratio = i / (sorted.length - 1 || 1);
          return `rgba(${Math.round(254 - ratio * 69)}, ${Math.round(205 - ratio * 13)}, ${Math.round(140 + ratio * (137 - 140))}, 0.75)`;
        }),
        borderColor: 'rgba(255, 255, 255, 0.2)',
        borderWidth: 1,
        borderRadius: 4,
        barThickness: 20
      }]
    },
    options: {
      indexAxis: 'y',
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: false },
        tooltip: {
          callbacks: {
            label: (item) => {
              const grade = sorted[item.dataIndex];
              const avgTime = (grade.pace_ms / 1000).toFixed(3);
              const delta = (grade.pace_delta_ms / 1000).toFixed(3);
              return [`Avg: ${avgTime}s`, `Delta: +${delta}s`];
            }
          }
        }
      },
      scales: {
        x: {
          title: { display: true, text: 'Delta to Fastest (seconds)', color: 'rgba(255, 255, 255, 0.5)' },
          beginAtZero: true,
          grid: { color: 'rgba(255, 255, 255, 0.08)' },
          ticks: { color: 'rgba(255, 255, 255, 0.6)' }
        },
        y: {
          grid: { display: false },
          ticks: { color: 'rgba(255, 255, 255, 0.85)', font: { weight: '500' } }
        }
      }
    }
  });

  showChart('paceComparisonChart');
}

function renderStintTimelineChart(data) {
  destroyChart('stintTimelineChart');
  const ctx = document.getElementById('stintTimelineChart');
  if (!ctx) return;

  const stints = data.stints || [];
  if (stints.length === 0) {
    const loader = ctx.parentElement.querySelector('.chart-loading');
    if (loader) {
      loader.style.display = 'flex';
      loader.textContent = 'No stint data available';
    }
    return;
  }

  const drivers = [...new Set(stints.map(s => s.driver))].sort();
  const datasets = [];

  drivers.forEach(driver => {
    const driverStints = stints.filter(s => s.driver === driver).sort((a, b) => a.stint_no - b.stint_no);
    let currentLap = 1;

    driverStints.forEach(stint => {
      const compound = stint.compound || 'UNKNOWN';
      datasets.push({
        label: compound,
        data: [{
          x: [currentLap, currentLap + (stint.laps || 0)],
          y: driver
        }],
        backgroundColor: COMPOUND_COLORS[compound] || '#9E9E9E',
        borderColor: COMPOUND_BORDER_COLORS[compound] || '#666666',
        borderWidth: 1,
        borderSkipped: false,
        barPercentage: 0.7,
        categoryPercentage: 0.85,
        borderRadius: 3
      });
      currentLap += stint.laps || 0;
    });
  });

  window.chartInstances['stintTimelineChart'] = new Chart(ctx, {
    type: 'bar',
    data: { labels: drivers, datasets },
    options: {
      indexAxis: 'y',
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          display: true,
          position: 'top',
          labels: {
            padding: 15,
            generateLabels: () => {
              return Object.entries(COMPOUND_COLORS)
                .filter(([k]) => k !== 'UNKNOWN')
                .map(([label, color]) => ({
                  text: label,
                  fillStyle: color,
                  strokeStyle: COMPOUND_BORDER_COLORS[label],
                  lineWidth: 1
                }));
            }
          }
        },
        tooltip: {
          callbacks: {
            title: (items) => items[0].dataset.label,
            label: (item) => {
              const range = item.raw.x;
              return `Laps ${range[0]}-${range[1]} (${range[1] - range[0]} laps)`;
            }
          }
        }
      },
      scales: {
        x: {
          type: 'linear',
          title: { display: true, text: 'Lap', color: 'rgba(255, 255, 255, 0.5)' },
          min: 0,
          stacked: true,
          grid: { color: 'rgba(255, 255, 255, 0.08)' },
          ticks: { color: 'rgba(255, 255, 255, 0.6)' }
        },
        y: {
          stacked: true,
          grid: { display: false },
          ticks: { color: 'rgba(255, 255, 255, 0.85)', font: { weight: '500' } }
        }
      }
    }
  });

  showChart('stintTimelineChart');
}

function renderDriverGradesRadar(data) {
  destroyChart('driverGradesRadar');
  const ctx = document.getElementById('driverGradesRadar');
  if (!ctx) return;

  const grades = data.driver_pace_grades || [];
  const fullGrades = grades
    .filter(g => g.source === 'drive_grade_db')
    .sort((a, b) => (b.total_grade || 0) - (a.total_grade || 0));

  if (fullGrades.length === 0) {
    const loader = ctx.parentElement.querySelector('.chart-loading');
    if (loader) {
      loader.style.display = 'flex';
      loader.textContent = 'No driver grades available';
    }
    return;
  }

  const topDrivers = fullGrades.slice(0, 5);

  const datasets = topDrivers.map((grade, index) => ({
    label: grade.driver,
    data: [
      grade.consistency || 0,
      grade.racecraft || 0,
      grade.team_strategy || 0,
      100 - (grade.penalties || 0)
    ],
    borderColor: getDriverColor(grade.driver),
    backgroundColor: getDriverColor(grade.driver, 0.15),
    borderWidth: 2,
    pointBackgroundColor: getDriverColor(grade.driver),
    pointRadius: 4,
    pointHoverRadius: 6
  }));

  window.chartInstances['driverGradesRadar'] = new Chart(ctx, {
    type: 'radar',
    data: {
      labels: ['Consistency', 'Racecraft', 'Strategy', 'Clean Driving'],
      datasets
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          position: 'top',
          labels: { boxWidth: 12, usePointStyle: true, padding: 15 }
        },
        tooltip: {
          callbacks: {
            label: (item) => {
              const driver = topDrivers[item.datasetIndex];
              return `${item.dataset.label}: ${item.raw.toFixed(1)}`;
            }
          }
        }
      },
      scales: {
        r: {
          min: 0,
          max: 100,
          ticks: { stepSize: 20, backdropColor: 'transparent', color: 'rgba(255, 255, 255, 0.5)' },
          pointLabels: { font: { size: 12 }, color: 'rgba(255, 255, 255, 0.85)' },
          grid: { color: 'rgba(255, 255, 255, 0.1)' },
          angleLines: { color: 'rgba(255, 255, 255, 0.1)' }
        }
      }
    }
  });

  showChart('driverGradesRadar');
}
</script>
