<script>
// Compound colors for tire strategies
const COMPOUND_COLORS = {
  'SOFT': '#ff4444',
  'MEDIUM': '#ffcc00',
  'HARD': '#ffffff',
  'INTERMEDIATE': '#00cc00',
  'WET': '#0066ff',
  'UNKNOWN': '#888888'
};

const COMPOUND_BORDER_COLORS = {
  'SOFT': '#cc0000',
  'MEDIUM': '#cc9900',
  'HARD': '#cccccc',
  'INTERMEDIATE': '#009900',
  'WET': '#0044cc',
  'UNKNOWN': '#666666'
};

// Driver colors (approximated from team colors)
const DRIVER_COLORS = {
  'VER': '#3671C6', 'PER': '#3671C6',  // Red Bull
  'HAM': '#27F4D2', 'RUS': '#27F4D2',  // Mercedes
  'LEC': '#E8002D', 'SAI': '#E8002D',  // Ferrari
  'NOR': '#FF8000', 'PIA': '#FF8000',  // McLaren
  'ALO': '#229971', 'STR': '#229971',  // Aston Martin
  'GAS': '#2293D1', 'OCO': '#2293D1',  // Alpine
  'BOT': '#C92D4B', 'ZHO': '#C92D4B',  // Alfa Romeo
  'TSU': '#6692FF', 'RIC': '#6692FF', 'LAW': '#6692FF',  // AlphaTauri/RB
  'MAG': '#B6BABD', 'HUL': '#B6BABD',  // Haas
  'ALB': '#64C4FF', 'SAR': '#64C4FF', 'COL': '#64C4FF',  // Williams
};

function getDriverColor(driver, alpha = 1) {
  const baseColor = DRIVER_COLORS[driver] || '#888888';
  // Convert hex to rgba
  const r = parseInt(baseColor.slice(1, 3), 16);
  const g = parseInt(baseColor.slice(3, 5), 16);
  const b = parseInt(baseColor.slice(5, 7), 16);
  return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}

function destroyChart(id) {
  if (window.chartInstances[id]) {
    window.chartInstances[id].destroy();
    delete window.chartInstances[id];
  }
}

function showChart(containerId) {
  const container = document.getElementById(containerId).parentElement;
  const loader = container.querySelector('.chart-loading');
  const canvas = container.querySelector('canvas');
  if (loader) loader.style.display = 'none';
  if (canvas) canvas.style.display = 'block';
}

// 1. Lap Time Progression Chart
function renderLapTimeChart(data) {
  destroyChart('lapTimeChart');
  const ctx = document.getElementById('lapTimeChart');
  if (!ctx) return;

  const laps = data.laps.filter(l => l.lap_ms && l.lap_ms > 0);
  if (laps.length === 0) {
    showChart('lapTimeChart');
    return;
  }

  const drivers = [...new Set(laps.map(l => l.driver))].sort();

  const datasets = drivers.map(driver => {
    const driverLaps = laps
      .filter(l => l.driver === driver)
      .sort((a, b) => a.lap - b.lap);

    return {
      label: driver,
      data: driverLaps.map(l => ({
        x: l.lap,
        y: l.lap_ms / 1000,
        compound: l.compound,
        pit: l.pit
      })),
      borderColor: getDriverColor(driver),
      backgroundColor: getDriverColor(driver, 0.1),
      borderWidth: 2,
      pointRadius: (ctx) => {
        const point = ctx.raw;
        return point && point.pit ? 6 : 2;
      },
      pointStyle: (ctx) => {
        const point = ctx.raw;
        return point && point.pit ? 'triangle' : 'circle';
      },
      pointBackgroundColor: (ctx) => {
        const point = ctx.raw;
        if (!point) return getDriverColor(driver);
        return COMPOUND_COLORS[point.compound] || getDriverColor(driver);
      },
      tension: 0.1,
      fill: false
    };
  });

  window.chartInstances['lapTimeChart'] = new Chart(ctx, {
    type: 'line',
    data: { datasets },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      interaction: {
        mode: 'nearest',
        axis: 'x',
        intersect: false
      },
      plugins: {
        legend: {
          position: 'top',
          labels: {
            boxWidth: 12,
            usePointStyle: true
          }
        },
        tooltip: {
          callbacks: {
            title: (items) => `Lap ${items[0].raw.x}`,
            label: (item) => {
              const point = item.raw;
              const time = point.y.toFixed(3);
              const compound = point.compound || 'Unknown';
              const pitLabel = point.pit ? ' (PIT)' : '';
              return `${item.dataset.label}: ${time}s [${compound}]${pitLabel}`;
            }
          }
        }
      },
      scales: {
        x: {
          type: 'linear',
          title: { display: true, text: 'Lap' },
          min: 1
        },
        y: {
          title: { display: true, text: 'Lap Time (seconds)' },
          suggestedMin: Math.min(...laps.map(l => l.lap_ms)) / 1000 - 2,
          suggestedMax: Math.max(...laps.map(l => l.lap_ms)) / 1000 + 2
        }
      }
    }
  });

  showChart('lapTimeChart');
}

// 2. Driver Pace Comparison Chart
function renderPaceComparisonChart(data) {
  destroyChart('paceComparisonChart');
  const ctx = document.getElementById('paceComparisonChart');
  if (!ctx) return;

  const grades = data.driver_pace_grades || [];
  if (grades.length === 0) {
    showChart('paceComparisonChart');
    return;
  }

  // Sort by pace (fastest first)
  const sorted = [...grades].sort((a, b) => {
    const aMs = a.pace_ms || a.total_grade || 0;
    const bMs = b.pace_ms || b.total_grade || 0;
    return aMs - bMs;
  });

  const bestPace = sorted[0].pace_ms || 0;

  window.chartInstances['paceComparisonChart'] = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: sorted.map(g => g.driver),
      datasets: [{
        label: 'Pace Delta (seconds)',
        data: sorted.map(g => ((g.pace_delta_ms || 0) / 1000)),
        backgroundColor: sorted.map((g, i) => {
          const ratio = i / (sorted.length - 1 || 1);
          const r = Math.round(34 + ratio * 200);
          const g2 = Math.round(197 - ratio * 150);
          const b = Math.round(94 - ratio * 50);
          return `rgba(${r}, ${g2}, ${b}, 0.8)`;
        }),
        borderColor: sorted.map(g => getDriverColor(g.driver)),
        borderWidth: 2
      }]
    },
    options: {
      indexAxis: 'y',
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { display: false },
        tooltip: {
          callbacks: {
            label: (item) => {
              const grade = sorted[item.dataIndex];
              const avgTime = (grade.pace_ms / 1000).toFixed(3);
              const delta = (grade.pace_delta_ms / 1000).toFixed(3);
              return [`Avg: ${avgTime}s`, `Delta: +${delta}s`];
            }
          }
        }
      },
      scales: {
        x: {
          title: { display: true, text: 'Delta to Fastest (seconds)' },
          beginAtZero: true
        },
        y: {
          title: { display: false }
        }
      }
    }
  });

  showChart('paceComparisonChart');
}

// 3. Stint Strategy Timeline Chart
function renderStintTimelineChart(data) {
  destroyChart('stintTimelineChart');
  const ctx = document.getElementById('stintTimelineChart');
  if (!ctx) return;

  const stints = data.stints || [];
  if (stints.length === 0) {
    showChart('stintTimelineChart');
    return;
  }

  // Group stints by driver
  const driverStints = {};
  stints.forEach(s => {
    if (!driverStints[s.driver]) driverStints[s.driver] = [];
    driverStints[s.driver].push(s);
  });

  const drivers = Object.keys(driverStints).sort();

  // Calculate lap positions for each stint
  const datasets = [];
  drivers.forEach((driver, driverIndex) => {
    let currentLap = 1;
    driverStints[driver]
      .sort((a, b) => a.stint_no - b.stint_no)
      .forEach(stint => {
        const compound = stint.compound || 'UNKNOWN';
        datasets.push({
          label: `${driver} - Stint ${stint.stint_no}`,
          data: [{
            x: [currentLap, currentLap + (stint.laps || 0)],
            y: driver
          }],
          backgroundColor: COMPOUND_COLORS[compound] || '#888888',
          borderColor: COMPOUND_BORDER_COLORS[compound] || '#666666',
          borderWidth: 1,
          borderSkipped: false,
          barPercentage: 0.7,
          categoryPercentage: 0.8
        });
        currentLap += stint.laps || 0;
      });
  });

  window.chartInstances['stintTimelineChart'] = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: drivers,
      datasets: datasets
    },
    options: {
      indexAxis: 'y',
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          display: true,
          position: 'top',
          labels: {
            generateLabels: () => {
              return Object.entries(COMPOUND_COLORS)
                .filter(([k]) => k !== 'UNKNOWN')
                .map(([compound, color]) => ({
                  text: compound,
                  fillStyle: color,
                  strokeStyle: COMPOUND_BORDER_COLORS[compound],
                  lineWidth: 1
                }));
            }
          }
        },
        tooltip: {
          callbacks: {
            title: (items) => items[0].dataset.label,
            label: (item) => {
              const range = item.raw.x;
              return `Laps ${range[0]} - ${range[1]} (${range[1] - range[0]} laps)`;
            }
          }
        }
      },
      scales: {
        x: {
          type: 'linear',
          title: { display: true, text: 'Lap' },
          min: 0,
          stacked: true
        },
        y: {
          stacked: true,
          title: { display: false }
        }
      }
    }
  });

  showChart('stintTimelineChart');
}

// 4. Driver Grades Radar Chart
function renderDriverGradesRadar(data) {
  destroyChart('driverGradesRadar');
  const ctx = document.getElementById('driverGradesRadar');
  if (!ctx) return;

  const grades = data.driver_pace_grades || [];
  // Filter to drivers with full grade data (from drive_grade_db source)
  const fullGrades = grades.filter(g => g.source === 'drive_grade_db');

  // If no DB grades, show a message
  if (fullGrades.length === 0) {
    const container = ctx.parentElement;
    const loader = container.querySelector('.chart-loading');
    if (loader) {
      loader.style.display = 'flex';
      loader.textContent = 'No driver grade data available';
    }
    return;
  }

  // Take top 5 drivers for readability
  const topDrivers = fullGrades.slice(0, 5);

  const datasets = topDrivers.map((grade, index) => ({
    label: grade.driver,
    data: [
      grade.consistency || 0,
      grade.racecraft || 0,
      grade.team_strategy || 0,
      100 - (grade.penalties || 0)  // Invert penalties so higher = better
    ],
    borderColor: getDriverColor(grade.driver),
    backgroundColor: getDriverColor(grade.driver, 0.2),
    borderWidth: 2,
    pointBackgroundColor: getDriverColor(grade.driver),
    pointRadius: 4
  }));

  window.chartInstances['driverGradesRadar'] = new Chart(ctx, {
    type: 'radar',
    data: {
      labels: ['Consistency', 'Racecraft', 'Strategy', 'Clean Driving'],
      datasets: datasets
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          position: 'top',
          labels: {
            boxWidth: 12,
            usePointStyle: true
          }
        },
        tooltip: {
          callbacks: {
            label: (item) => {
              const driver = topDrivers[item.datasetIndex];
              const value = item.raw.toFixed(1);
              return `${item.dataset.label}: ${value}`;
            }
          }
        }
      },
      scales: {
        r: {
          min: 0,
          max: 100,
          ticks: {
            stepSize: 20
          },
          pointLabels: {
            font: { size: 12 }
          }
        }
      }
    }
  });

  showChart('driverGradesRadar');
}
</script>
